# 당신에게 2차원 배열과 쿼리들이 주어집니다.
# 각 쿼리는 배열의 부분 직사각형 영역과 대각선 방향을 지정합니다.
# 당신은 각 쿼리마다 해당 쿼리가 가리키는 부분 직사각형 영역을
# 대각선 방향에 맞게 "대각 반사" 해야 합니다.

# "대각 반사"란, 해당 부분 직사각형 영역을 대각선 별로 나눈 다음에,
# 각 대각선의 모든 숫자들을 대각 방향으로 반전시키는 것을 의미합니다.

# 2차원 배열 grid와 쿼리들의 목록 queries가 매개변수로 주어집니다.
# 주어진 쿼리들을 모두 순서대로 처리한 후 배열의 최종 결과를 return하도록
# solution 함수를 완성해주세요.

# 제한 사항
# · 2 <= grid의 행(가로줄)의 개수 <= 50
# · 2 <= gird의 열(세로줄)의 개수 <= 50
#     · 0 <= grid의 모든 수 < grid의 행의 개수 x grid의 열의 개수
# · 1 <= queries의 행의 개수 <= 50
#     · queries의 각 행은 하나의 쿼리를 의미하고, 길이는 5이며, [r1, c1, r2, c2, typ] 형태입니다.
#     · 1 <= r1 < r2 <= grid의 행의 개수
#     · 1 <= c1 < c2 <= grid의 열의 개수
#     · r1행 c1열부터 r2행 c2열까지의 부분 직사각형 영역을 대각 반사해야함을 의미합니다.
#     · typ은 -1 또는 1입니다.
#     · typ이 -1일 경우, 행 번호 + 열 번호가 같은 칸끼리 같은 대각선으로 묶습니다.
#     · typ가 1일 경우, 행 번호 - 열 번호가 같은 칸끼리 같은 대각선으로 묶습니다.

# 입출력 예
# grid
# [[0, 1, 2, 3, 4, 5, 6, 7],
#  [8, 9, 10, 11, 12, 13, 14, 15],
#  [16, 17, 18, 19, 20, 21, 22, 23],
#  [24, 25, 26, 27, 28, 29, 30, 31],
#  [32, 33, 34, 35, 36, 37, 38, 39]]

# queries
# [[1, 2, 5, 7, -1],
#  [2, 1, 4, 8, 1],
#  [1, 1, 5, 8, -1],
#  [2, 2, 4, 7, 1]]

# result
# [[0, 12, 4, 24, 32, 5, 6, 14],
#  [1, 31, 23, 36, 26, 18, 10, 22],
#  [9, 37, 11, 19, 20, 28, 2, 30],
#  [17, 29, 21, 13, 3, 16, 8, 38],
#  [25, 33, 34, 7, 15, 35, 27, 39]]

def solution(grid, queries):
    for query in queries:
        r1, c1, r2, c2, typ = query
        diagonals = dict()  # 각 대각선의 원소를 저장할 딕셔너리
        
        # 대각선의 원소들을 딕셔너리에 저장
        for i in range(r1, r2 + 1):
            for j in range(c1, c2 + 1):
                if typ == -1:
                    key = i + j
                else:
                    key = i - j
                if key not in diagonals:
                    diagonals[key] = []
                diagonals[key].append(grid[i-1][j-1])
        
        # 딕셔너리의 원소들을 반전
        for key in diagonals:
            diagonals[key].reverse()

        # 원래의 2차원 배열을 반전된 리스트를 이용하여 업데이트
        for i in range(r1, r2 + 1):
            for j in range(c1, c2 + 1):
                if typ == -1:
                    key = i + j
                else:
                    key = i - j
                grid[i-1][j-1] = diagonals[key].pop(0)

    return grid
